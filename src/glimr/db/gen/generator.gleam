//// ------------------------------------------------------------
//// Code Generator
//// ------------------------------------------------------------
////
//// Generates typed Gleam repository modules from parsed schema
//// definitions and SQL query files. Produces complete,
//// formatted Gleam code including:
////
//// - Model type definitions matching the schema
//// - Decoder functions for database rows
//// - Query functions for each SQL file (returning Results)
//// - Row types for queries with custom SELECT columns
////

import gleam/int
import gleam/list
import gleam/option.{None, Some}
import gleam/string
import glimr/db/gen/parser.{type ParsedQuery}
import glimr/db/gen/parser/columns.{type SelectedColumn}
import glimr/db/gen/schema_parser.{type ColumnType, type Table}
import glimr/db/gen/schema_parser/codegen

// ------------------------------------------------------------- Public Functions

/// ------------------------------------------------------------
/// Generate
/// ------------------------------------------------------------
///
/// Generates a complete Gleam repository module for a model.
/// Combines the header, imports, model type, decoder, and all
/// query functions into a single module string.
///
pub fn generate(
  model_name: String,
  table: Table,
  queries: List(#(String, String, ParsedQuery)),
) -> String {
  let header = generate_header(model_name)
  let imports = generate_imports(table)
  let model_type = generate_model_type(model_name, table)
  let model_decoder = generate_model_decoder(model_name, table)
  let query_code = generate_queries(table, queries)

  string.join([header, imports, model_type, model_decoder, query_code], "\n\n")
}

// ------------------------------------------------------------- Private Functions

/// ------------------------------------------------------------
/// Generate Header
/// ------------------------------------------------------------
///
/// Generates the module documentation comment with a warning
/// that the file is auto-generated and should not be edited.
///
fn generate_header(model_name: String) -> String {
  "//// "
  <> pascal_case(model_name)
  <> " Model (GENERATED - DO NOT EDIT)\n////\n//// Generated by glimr/db/gen"
}

/// ------------------------------------------------------------
/// Generate Imports
/// ------------------------------------------------------------
///
/// Generates the import statements for the repository module.
/// Conditionally includes Option and glimr_decode imports based
/// on whether the schema has nullable or boolean columns.
///
fn generate_imports(table: Table) -> String {
  let columns = schema_parser.columns(table)
  let has_boolean =
    list.any(columns, fn(col) { col.column_type == schema_parser.Boolean })
  let has_nullable = list.any(columns, fn(col) { col.nullable })

  let base_imports = "import gleam/dynamic/decode"

  let option_import = case has_nullable {
    True -> "\nimport gleam/option.{type Option}"
    False -> ""
  }

  let glimr_decode_import = case has_boolean {
    True -> "\nimport glimr/db/decode as glimr_decode"
    False -> ""
  }

  base_imports
  <> option_import
  <> "\nimport glimr/db/connection.{type Connection, type DbError, NotFound}"
  <> glimr_decode_import
  <> "\nimport glimr/db/pool.{type Pool}
import glimr/db/query"
}

/// ------------------------------------------------------------
/// Generate Model Type
/// ------------------------------------------------------------
///
/// Generates the main model type definition from the schema.
/// Maps column types to Gleam types and wraps nullable columns
/// in Option.
///
fn generate_model_type(model_name: String, table: Table) -> String {
  let type_name = pascal_case(model_name)
  let columns = schema_parser.columns(table)

  let fields =
    list.map(columns, fn(col) {
      let gleam_type = codegen.gleam_type(col.column_type)
      let type_str = case col.nullable {
        True -> "Option(" <> gleam_type <> ")"
        False -> gleam_type
      }
      "    " <> col.name <> ": " <> type_str
    })

  "pub type "
  <> type_name
  <> " {\n  "
  <> type_name
  <> "(\n"
  <> string.join(fields, ",\n")
  <> ",\n  )\n}"
}

/// ------------------------------------------------------------
/// Generate Model Decoder
/// ------------------------------------------------------------
///
/// Generates the public decoder function for the main model 
/// type. Creates field decoders for each column with proper 
/// handling of nullable fields using decode.optional.
///
fn generate_model_decoder(model_name: String, table: Table) -> String {
  let type_name = pascal_case(model_name)
  let columns = schema_parser.columns(table)

  let field_decoders =
    list.index_map(columns, fn(col, idx) {
      let decoder = codegen.decoder_fn(col.column_type)
      let decoder_with_nullable = case col.nullable {
        True -> "decode.optional(" <> decoder <> ")"
        False -> decoder
      }
      "  use "
      <> col.name
      <> " <- decode.field("
      <> int.to_string(idx)
      <> ", "
      <> decoder_with_nullable
      <> ")"
    })

  let field_names = list.map(columns, fn(col) { col.name })
  let constructor_call =
    type_name <> "(" <> string.join(field_names, ", ") <> ")"

  "pub fn decoder() -> decode.Decoder("
  <> type_name
  <> ") {\n"
  <> string.join(field_decoders, "\n")
  <> "\n"
  <> "  decode.success("
  <> constructor_call
  <> ")\n}"
}

/// ------------------------------------------------------------
/// Generate Queries
/// ------------------------------------------------------------
///
/// Generates code for all query functions by mapping over the
/// list of parsed queries and joining the results.
///
fn generate_queries(
  table: Table,
  queries: List(#(String, String, ParsedQuery)),
) -> String {
  let query_codes =
    list.map(queries, fn(query_tuple) {
      let #(query_name, sql, parsed) = query_tuple
      generate_single_query(table, query_name, sql, parsed)
    })

  string.join(query_codes, "\n\n")
}

/// ------------------------------------------------------------
/// Generate Single Query
/// ------------------------------------------------------------
///
/// Generates code for a single SQL query. For queries with no
/// SELECT columns, generates an execute-style function. For
/// queries with columns, generates a row type, decoder, and
/// query function with both callback and _or variants.
///
fn generate_single_query(
  table: Table,
  query_name: String,
  sql: String,
  parsed: ParsedQuery,
) -> String {
  let fn_name = snake_case(query_name)

  let columns_with_types = resolve_column_types(table, parsed.columns)

  let param_types = resolve_param_types(table, parsed.param_columns)

  case list.is_empty(columns_with_types) {
    True -> {
      generate_execute_function(fn_name, sql, parsed.params, param_types)
    }
    False -> {
      let row_type_name = pascal_case(query_name) <> "Row"

      let row_type = generate_row_type(row_type_name, columns_with_types)

      let row_decoder = generate_row_decoder(row_type_name, columns_with_types)

      let query_fn =
        generate_query_function(
          fn_name,
          row_type_name,
          sql,
          parsed.params,
          columns_with_types,
          param_types,
        )

      string.join([row_type, row_decoder, query_fn], "\n\n")
    }
  }
}

/// ------------------------------------------------------------
/// Resolve Param Types
/// ------------------------------------------------------------
///
/// Maps parameter placeholders to their types from the schema.
/// Strips start_/end_ prefixes for BETWEEN parameters when
/// looking up the column type.
///
fn resolve_param_types(
  table: Table,
  param_columns: List(#(Int, String)),
) -> List(#(Int, String, ColumnType)) {
  let schema_columns = schema_parser.columns(table)

  list.filter_map(param_columns, fn(pc) {
    let #(param_num, col_name) = pc
    // Strip start_/end_ prefixes for BETWEEN params when looking up type
    let lookup_name = case string.starts_with(col_name, "start_") {
      True -> string.drop_start(col_name, 6)
      False ->
        case string.starts_with(col_name, "end_") {
          True -> string.drop_start(col_name, 4)
          False -> col_name
        }
    }
    case list.find(schema_columns, fn(sc) { sc.name == lookup_name }) {
      Ok(col) -> Ok(#(param_num, col_name, col.column_type))
      Error(_) -> Error(Nil)
    }
  })
}

/// ------------------------------------------------------------
/// Resolve Column Types
/// ------------------------------------------------------------
///
/// Maps selected columns to their types from the schema. 
/// Handles star (*) expansion to all schema columns, alias 
/// resolution, and aggregate function type inference.
///
fn resolve_column_types(
  table: Table,
  columns: List(SelectedColumn),
) -> List(#(String, ColumnType, Bool)) {
  let schema_columns = schema_parser.columns(table)

  // Check if there's a * (star) select - expand to all schema columns
  let has_star = list.any(columns, fn(sel_col) { sel_col.name == "*" })

  case has_star {
    True -> {
      // Expand * to all schema columns
      list.map(schema_columns, fn(col) {
        #(col.name, col.column_type, col.nullable)
      })
    }
    False -> {
      list.map(columns, fn(sel_col) {
        let name = case sel_col.alias {
          Some(alias) -> alias
          None -> sel_col.name
        }

        // First check if it's an aggregate function
        case infer_aggregate_type(sel_col.name) {
          Some(agg_type) -> #(name, agg_type, False)
          None -> {
            // Find matching column in schema
            let schema_col =
              list.find(schema_columns, fn(sc) { sc.name == sel_col.name })

            case schema_col {
              Ok(col) -> #(name, col.column_type, col.nullable)
              Error(_) -> #(name, schema_parser.String, False)
              // Default to String if not found
            }
          }
        }
      })
    }
  }
}

/// ------------------------------------------------------------
/// Infer Aggregate Type
/// ------------------------------------------------------------
///
/// Infers the return type for SQL aggregate functions. COUNT
/// returns Int, SUM returns Int, AVG returns Float.
///
fn infer_aggregate_type(expr: String) -> option.Option(ColumnType) {
  let upper = string.uppercase(expr)

  // COUNT always returns Int
  case string.starts_with(upper, "COUNT(") {
    True -> Some(schema_parser.Int)
    False -> {
      // SUM typically returns Int (could be Float for float columns)
      case string.starts_with(upper, "SUM(") {
        True -> Some(schema_parser.Int)
        False -> {
          // AVG returns Float
          case string.starts_with(upper, "AVG(") {
            True -> Some(schema_parser.Float)
            False -> None
          }
        }
      }
    }
  }
}

/// ------------------------------------------------------------
/// Generate Row Type
/// ------------------------------------------------------------
///
/// Generates a row type for a query's SELECT columns. Similar
/// to generate_model_type but for query-specific result types.
///
fn generate_row_type(
  type_name: String,
  columns: List(#(String, ColumnType, Bool)),
) -> String {
  let fields =
    list.map(columns, fn(col_tuple) {
      let #(name, col_type, nullable) = col_tuple
      let gleam_type = codegen.gleam_type(col_type)
      let type_str = case nullable {
        True -> "Option(" <> gleam_type <> ")"
        False -> gleam_type
      }
      "    " <> name <> ": " <> type_str
    })

  "pub type "
  <> type_name
  <> " {\n  "
  <> type_name
  <> "(\n"
  <> string.join(fields, ",\n")
  <> ",\n  )\n}"
}

/// ------------------------------------------------------------
/// Generate Row Decoder
/// ------------------------------------------------------------
///
/// Generates a private decoder function for a query's row type.
/// Creates field decoders by index position with nullable 
/// handling.
///
fn generate_row_decoder(
  type_name: String,
  columns: List(#(String, ColumnType, Bool)),
) -> String {
  let field_decoders =
    list.index_map(columns, fn(col_tuple, idx) {
      let #(name, col_type, nullable) = col_tuple
      let decoder = codegen.decoder_fn(col_type)
      let decoder_with_nullable = case nullable {
        True -> "decode.optional(" <> decoder <> ")"
        False -> decoder
      }
      "  use "
      <> name
      <> " <- decode.field("
      <> int.to_string(idx)
      <> ", "
      <> decoder_with_nullable
      <> ")"
    })

  let field_names =
    list.map(columns, fn(col_tuple) {
      let #(name, _, _) = col_tuple
      name
    })
  let constructor_call =
    type_name <> "(" <> string.join(field_names, ", ") <> ")"

  "fn "
  <> snake_case(type_name)
  <> "_decoder() -> decode.Decoder("
  <> type_name
  <> ") {\n"
  <> string.join(field_decoders, "\n")
  <> "\n"
  <> "  decode.success("
  <> constructor_call
  <> ")\n}"
}

/// ------------------------------------------------------------
/// Generate Query Function
/// ------------------------------------------------------------
///
/// Generates two query functions: the main function accepts a
/// Pool and auto-manages connections, while the _wc (with
/// connection) variant accepts a Connection for use in
/// transactions. Handles both single-row and list queries.
///
fn generate_query_function(
  fn_name: String,
  row_type_name: String,
  sql: String,
  params: List(Int),
  _columns: List(#(String, ColumnType, Bool)),
  param_types: List(#(Int, String, ColumnType)),
) -> String {
  let param_count = list.length(params)

  // Detect if this is a multi-row query (list_*) or single-row (everything else)
  let is_single_row = !string.starts_with(fn_name, "list_")

  // Generate parameter list with proper types and labeled names
  let param_list = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, col_type)) -> {
              let gleam_type = codegen.gleam_type(col_type)
              col_name <> " " <> col_name <> ": " <> gleam_type
            }
            Error(_) -> {
              let name = "p" <> int.to_string(n)
              name <> " " <> name <> ": String"
            }
          }
        }),
        ", ",
      )
  }

  // Generate parameter values with connection wrappers
  let param_values = case param_count {
    0 -> "[]"
    _ ->
      "["
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, col_type)) -> {
              let wrapper = connection_wrapper(col_type)
              wrapper <> "(" <> col_name <> ")"
            }
            Error(_) -> "connection.string(p" <> int.to_string(n) <> ")"
          }
        }),
        ", ",
      )
      <> "]"
  }

  // Generate param names for passing to _wc function (with labels)
  let param_names = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, _)) -> col_name <> ": " <> col_name
            Error(_) -> {
              let name = "p" <> int.to_string(n)
              name <> ": " <> name
            }
          }
        }),
        ", ",
      )
  }

  // Strip comments and escape the SQL for Gleam string
  let escaped_sql = escape_string(strip_sql_comments(sql))
  let decoder_fn = snake_case(row_type_name) <> "_decoder()"

  // Generate _wc (with connection) variant
  let wc_fn = case is_single_row {
    True ->
      "pub fn "
      <> fn_name
      <> "_wc(conn conn: Connection"
      <> param_list
      <> ") -> Result("
      <> row_type_name
      <> ", DbError) {\n"
      <> "  case query.select_all(conn, \""
      <> escaped_sql
      <> "\", "
      <> param_values
      <> ", "
      <> decoder_fn
      <> ") {\n"
      <> "    Ok([row]) -> Ok(row)\n"
      <> "    Ok([]) -> Error(NotFound)\n"
      <> "    Ok(_) -> Error(connection.QueryError(\"Expected single row\"))\n"
      <> "    Error(e) -> Error(e)\n"
      <> "  }\n}"
    False ->
      "pub fn "
      <> fn_name
      <> "_wc(conn conn: Connection"
      <> param_list
      <> ") -> Result(List("
      <> row_type_name
      <> "), DbError) {\n"
      <> "  query.select_all(\n"
      <> "    conn,\n"
      <> "    \""
      <> escaped_sql
      <> "\",\n"
      <> "    "
      <> param_values
      <> ",\n"
      <> "    "
      <> decoder_fn
      <> ",\n"
      <> "  )\n}"
  }

  // Generate main function that accepts Pool
  let main_fn = case is_single_row {
    True ->
      "pub fn "
      <> fn_name
      <> "(pool pool: Pool"
      <> param_list
      <> ") -> Result("
      <> row_type_name
      <> ", DbError) {\n"
      <> "  case pool.checkout(pool) {\n"
      <> "    Ok(conn) -> {\n"
      <> "      let result = "
      <> fn_name
      <> "_wc(conn: conn"
      <> param_names
      <> ")\n"
      <> "      pool.release(pool, conn)\n"
      <> "      result\n"
      <> "    }\n"
      <> "    Error(e) -> Error(e)\n"
      <> "  }\n}"
    False ->
      "pub fn "
      <> fn_name
      <> "(pool pool: Pool"
      <> param_list
      <> ") -> Result(List("
      <> row_type_name
      <> "), DbError) {\n"
      <> "  case pool.checkout(pool) {\n"
      <> "    Ok(conn) -> {\n"
      <> "      let result = "
      <> fn_name
      <> "_wc(conn: conn"
      <> param_names
      <> ")\n"
      <> "      pool.release(pool, conn)\n"
      <> "      result\n"
      <> "    }\n"
      <> "    Error(e) -> Error(e)\n"
      <> "  }\n}"
  }

  string.join([main_fn, wc_fn], "\n\n")
}

/// ------------------------------------------------------------
/// Generate Execute Function
/// ------------------------------------------------------------
///
/// Generates two execute-style functions for queries without
/// SELECT columns (INSERT, UPDATE, DELETE). The main function
/// accepts Pool, the _wc variant accepts Connection. Returns
/// Result with the affected row count.
///
fn generate_execute_function(
  fn_name: String,
  sql: String,
  params: List(Int),
  param_types: List(#(Int, String, ColumnType)),
) -> String {
  let param_count = list.length(params)

  // Generate parameter list with proper types and labeled names
  let param_list = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, col_type)) -> {
              let gleam_type = codegen.gleam_type(col_type)
              col_name <> " " <> col_name <> ": " <> gleam_type
            }
            Error(_) -> {
              let name = "p" <> int.to_string(n)
              name <> " " <> name <> ": String"
            }
          }
        }),
        ", ",
      )
  }

  // Generate parameter values with connection wrappers
  let param_values = case param_count {
    0 -> "[]"
    _ ->
      "["
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, col_type)) -> {
              let wrapper = connection_wrapper(col_type)
              wrapper <> "(" <> col_name <> ")"
            }
            Error(_) -> "connection.string(p" <> int.to_string(n) <> ")"
          }
        }),
        ", ",
      )
      <> "]"
  }

  // Generate param names for passing to _wc function (with labels)
  let param_names = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        list.map(list.range(1, param_count), fn(n) {
          case list.find(param_types, fn(pt) { pt.0 == n }) {
            Ok(#(_, col_name, _)) -> col_name <> ": " <> col_name
            Error(_) -> {
              let name = "p" <> int.to_string(n)
              name <> ": " <> name
            }
          }
        }),
        ", ",
      )
  }

  // Strip comments and escape the SQL for Gleam string
  let escaped_sql = escape_string(strip_sql_comments(sql))

  // Generate _wc (with connection) variant
  let wc_fn =
    "pub fn "
    <> fn_name
    <> "_wc(conn conn: Connection"
    <> param_list
    <> ") -> Result(Int, DbError) {\n"
    <> "  query.execute(conn, \""
    <> escaped_sql
    <> "\", "
    <> param_values
    <> ")\n}"

  // Generate main function that accepts Pool
  let main_fn =
    "pub fn "
    <> fn_name
    <> "(pool pool: Pool"
    <> param_list
    <> ") -> Result(Int, DbError) {\n"
    <> "  case pool.checkout(pool) {\n"
    <> "    Ok(conn) -> {\n"
    <> "      let result = "
    <> fn_name
    <> "_wc(conn: conn"
    <> param_names
    <> ")\n"
    <> "      pool.release(pool, conn)\n"
    <> "      result\n"
    <> "    }\n"
    <> "    Error(e) -> Error(e)\n"
    <> "  }\n}"

  string.join([main_fn, wc_fn], "\n\n")
}

/// ------------------------------------------------------------
/// Connection Wrapper
/// ------------------------------------------------------------
///
/// Returns the appropriate connection.* wrapper function name
/// for a given column type 
/// (e.g., connection.int, connection.string).
///
fn connection_wrapper(col_type: ColumnType) -> String {
  case col_type {
    schema_parser.Id -> "connection.int"
    schema_parser.String -> "connection.string"
    schema_parser.Text -> "connection.string"
    schema_parser.Int -> "connection.int"
    schema_parser.BigInt -> "connection.int"
    schema_parser.Float -> "connection.float"
    schema_parser.Boolean -> "connection.bool"
    schema_parser.Timestamp -> "connection.string"
    schema_parser.UnixTimestamp -> "connection.int"
    schema_parser.Date -> "connection.string"
    schema_parser.Json -> "connection.string"
    schema_parser.Uuid -> "connection.string"
    schema_parser.Foreign(_) -> "connection.int"
  }
}

/// ------------------------------------------------------------
/// Pascal Case
/// ------------------------------------------------------------
///
/// Converts a snake_case string to PascalCase by splitting on
/// underscores and capitalizing each segment.
///
fn pascal_case(s: String) -> String {
  s
  |> string.split("_")
  |> list.map(capitalize)
  |> string.join("")
}

/// ------------------------------------------------------------
/// Snake Case
/// ------------------------------------------------------------
///
/// Converts a PascalCase string to snake_case by inserting
/// underscores before uppercase letters that follow lowercase.
///
fn snake_case(s: String) -> String {
  do_snake_case(string.to_graphemes(s), "", False)
}

/// ------------------------------------------------------------
/// Do Snake Case
/// ------------------------------------------------------------
///
/// Recursive helper for snake_case conversion. Tracks whether
/// the previous character was lowercase to decide when to
/// insert underscores.
///
fn do_snake_case(chars: List(String), acc: String, prev_lower: Bool) -> String {
  case chars {
    [] -> string.lowercase(acc)
    [c, ..rest] -> {
      let is_upper = c == string.uppercase(c) && c != string.lowercase(c)
      case is_upper && prev_lower {
        True -> do_snake_case(rest, acc <> "_" <> c, False)
        False -> do_snake_case(rest, acc <> c, !is_upper)
      }
    }
  }
}

/// ------------------------------------------------------------
/// Capitalize
/// ------------------------------------------------------------
///
/// Capitalizes the first character of a string, leaving the
/// rest unchanged.
///
fn capitalize(s: String) -> String {
  case string.pop_grapheme(s) {
    Ok(#(first, rest)) -> string.uppercase(first) <> rest
    Error(_) -> s
  }
}

/// ------------------------------------------------------------
/// Escape String
/// ------------------------------------------------------------
///
/// Escapes a string for use in generated Gleam code. Escapes
/// backslashes, quotes, and replaces newlines with spaces.
///
fn escape_string(s: String) -> String {
  s
  |> string.replace("\\", "\\\\")
  |> string.replace("\"", "\\\"")
  |> string.replace("\n", " ")
}

/// ------------------------------------------------------------
/// Strip SQL Comments
/// ------------------------------------------------------------
///
/// Removes both block (/* */) and line (--) comments from SQL,
/// then collapses multiple spaces into single spaces.
///
fn strip_sql_comments(sql: String) -> String {
  sql
  |> strip_block_comments()
  |> strip_line_comments()
  |> collapse_whitespace()
}

/// ------------------------------------------------------------
/// Strip Block Comments
/// ------------------------------------------------------------
///
/// Recursively removes /* */ block comments from SQL. Handles
/// nested removal by repeatedly finding and removing comment
/// blocks.
///
fn strip_block_comments(sql: String) -> String {
  case string.split_once(sql, "/*") {
    Error(_) -> sql
    Ok(#(before, after)) -> {
      case string.split_once(after, "*/") {
        Error(_) -> before
        Ok(#(_, rest)) -> strip_block_comments(before <> " " <> rest)
      }
    }
  }
}

/// ------------------------------------------------------------
/// Strip Line Comments
/// ------------------------------------------------------------
///
/// Removes -- line comments from SQL by splitting each line
/// at the comment marker and keeping only the code portion.
///
fn strip_line_comments(sql: String) -> String {
  sql
  |> string.split("\n")
  |> list.map(fn(line) {
    case string.split_once(line, "--") {
      Error(_) -> line
      Ok(#(before, _)) -> before
    }
  })
  |> string.join(" ")
}

/// ------------------------------------------------------------
/// Collapse Whitespace
/// ------------------------------------------------------------
///
/// Recursively replaces multiple consecutive spaces with single
/// spaces until no double-spaces remain, then trims the result.
///
fn collapse_whitespace(sql: String) -> String {
  let collapsed = string.replace(sql, "  ", " ")
  case collapsed == sql {
    True -> string.trim(sql)
    False -> collapse_whitespace(collapsed)
  }
}
